<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas & Happy Birthday</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Times New Roman', serif; }

        /* å¯†ç ä¿æŠ¤é¡µé¢ */
        #password-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a0a 50%, #0a0a1a 100%);
            z-index: 9999;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            font-family: 'Cinzel', 'Times New Roman', serif;
        }
        #password-screen.hidden { display: none; }
        .pw-title {
            color: #ffd700;
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            letter-spacing: 4px;
        }
        .pw-subtitle {
            color: rgba(255, 215, 0, 0.6);
            font-size: 14px;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        .pw-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #ffd700;
            padding: 15px 30px;
            font-size: 18px;
            text-align: center;
            letter-spacing: 8px;
            outline: none;
            border-radius: 5px;
            width: 200px;
            transition: all 0.3s;
        }
        .pw-input:focus {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }
        .pw-input::placeholder {
            color: rgba(255, 215, 0, 0.3);
            letter-spacing: 2px;
        }
        .pw-btn {
            margin-top: 20px;
            background: transparent;
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            padding: 12px 40px;
            font-size: 12px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        .pw-btn:hover {
            background: #ffd700;
            color: #000;
        }
        .pw-error {
            color: #ff6b6b;
            margin-top: 15px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .pw-error.show { opacity: 1; }
        .pw-hint {
            position: absolute;
            bottom: 40px;
            color: rgba(255, 215, 0, 0.3);
            font-size: 11px;
        }

        .snowflake {
            position: absolute;
            color: rgba(255, 255, 255, 0.3);
            font-size: 20px;
            animation: fall linear infinite;
        }
        @keyframes fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0.3; }
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column;
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
        }

        .ui-hidden { opacity: 0; pointer-events: none !important; }

        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.8s ease-out;
        }
        .loader-text {
            color: #d4af37; font-size: 14px; letter-spacing: 4px; margin-top: 20px;
            text-transform: uppercase; font-weight: 100;
        }
        .spinner {
            width: 40px; height: 40px; border: 1px solid rgba(212, 175, 55, 0.2);
            border-top: 1px solid #d4af37; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        h1 {
            color: #fceea7; font-size: 56px; margin: 0; font-weight: 400;
            letter-spacing: 6px;
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6);
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.9;
        }

        .hint-wrapper {
            margin-top: 20px;
            pointer-events: auto;
            text-align: center;
            transition: opacity 0.5s ease;
        }
        .hint-text {
            color: rgba(212, 175, 55, 0.6);
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
    </style>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- å¯†ç ä¿æŠ¤é¡µé¢ -->
    <div id="password-screen">
        <div class="pw-title">ğŸ„ A Gift For You ğŸ„</div>
        <div class="pw-subtitle">è¯·è¾“å…¥å¯†ç æŸ¥çœ‹</div>
        <input type="password" class="pw-input" id="pw-input" placeholder="****" maxlength="20" autofocus>
        <button class="pw-btn" onclick="checkPassword()">è¿›å…¥</button>
        <div class="pw-error" id="pw-error">å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•</div>
    </div>

    <script>
        // ========== åœ¨è¿™é‡Œè®¾ç½®ä½ çš„å¯†ç  ==========
        const SECRET_PASSWORD = "1226";  // ä½ çš„ä¸“å±å¯†ç 
        // ========================================

        // åˆ›å»ºé£˜è½çš„é›ªèŠ±
        function createSnowflakes() {
            const screen = document.getElementById('password-screen');
            for (let i = 0; i < 30; i++) {
                const flake = document.createElement('div');
                flake.className = 'snowflake';
                flake.innerHTML = ['â„', 'âœ¦', 'âœ§', 'Â·'][Math.floor(Math.random() * 4)];
                flake.style.left = Math.random() * 100 + '%';
                flake.style.animationDuration = (Math.random() * 3 + 4) + 's';
                flake.style.animationDelay = Math.random() * 5 + 's';
                flake.style.fontSize = (Math.random() * 15 + 10) + 'px';
                screen.appendChild(flake);
            }
        }
        createSnowflakes();

        // å¯†ç éªŒè¯
        function checkPassword() {
            const input = document.getElementById('pw-input');
            const error = document.getElementById('pw-error');

            if (input.value === SECRET_PASSWORD) {
                document.getElementById('password-screen').classList.add('hidden');
                initMainContent();
            } else {
                error.classList.add('show');
                input.value = '';
                input.focus();
                setTimeout(() => error.classList.remove('show'), 2000);
            }
        }

        // å›è½¦é”®ç¡®è®¤
        document.getElementById('pw-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') checkPassword();
        });

        // ä¸»å†…å®¹åˆå§‹åŒ–ï¼ˆå¯†ç æ­£ç¡®åæ‰æ‰§è¡Œï¼‰
        let mainInitialized = false;

        function initMainContent() {
            if (mainInitialized) return;
            mainInitialized = true;
            // è§¦å‘ Three.js åˆå§‹åŒ–
            window.dispatchEvent(new Event('startApp'));
            // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
            const bgm = document.getElementById('bgm');
            bgm.volume = 0.5;
            bgm.play().catch(() => {});
        }
    </script>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">Loading Holiday Magic</div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>

        <div class="hint-wrapper">
            <div class="hint-text">Q/E æ—‹è½¬ | F æŸ¥çœ‹ç…§ç‰‡ | S æ•£å¼€ | T èšåˆ | H éšè—</div>
        </div>
    </div>

    <!-- èƒŒæ™¯éŸ³ä¹ -->
    <audio id="bgm" loop preload="auto">
        <source src="music/bgm.mp3" type="audio/mpeg">
    </audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

        const CONFIG = {
            colors: {
                bg: 0x000000,
                champagneGold: 0xffd966,
                deepGreen: 0x03180a,
                accentRed: 0x990000,
            },
            particles: {
                count: 1500,
                dustCount: 2500,
                treeHeight: 24,
                treeRadius: 8
            },
            camera: { z: 50 }
        };

        const STATE = {
            mode: 'TREE',
            focusTarget: null,
            rotation: { x: 0, y: 0 },
            currentPhotoIndex: -1,
            showingGreeting: false,
            // æ‰‹åŠ¨æ—‹è½¬æ§åˆ¶
            manualRotation: {
                velocity: 0,          // å½“å‰æ—‹è½¬é€Ÿåº¦
                targetVelocity: 0,    // ç›®æ ‡æ—‹è½¬é€Ÿåº¦
                friction: 0.95,       // æƒ¯æ€§æ‘©æ“¦ç³»æ•°
                acceleration: 0.8,    // åŠ é€Ÿåº¦
                maxSpeed: 1.2         // æœ€å¤§æ—‹è½¬é€Ÿåº¦
            },
            keys: {
                q: false,
                e: false
            }
        };

        let scene, camera, renderer, composer;
        let mainGroup;
        let clock = new THREE.Clock();
        let particleSystem = [];
        let photoMeshGroup = new THREE.Group();
        let caneTexture;
        let snowLayers = [];  // å¤šå±‚é›ªèŠ±ç³»ç»Ÿ

        async function init() {
            try {
                initThree();
                setupEnvironment();
                setupLights();
                createTextures();
                createParticles();
                createDust();
                await createDefaultPhotos();
                setupPostProcessing();
                setupEvents();
                setupKeyboardControls();

                const loader = document.getElementById('loader');
                loader.style.opacity = 0;
                setTimeout(() => loader.remove(), 800);

                animate();
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('loader').innerHTML =
                    '<div style="color:#ff6666;text-align:center;">åŠ è½½å¤±è´¥<br><small>' + error.message + '</small></div>';
            }
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            // æ›´æŸ”å’Œçš„é›¾æ•ˆï¼Œå¢å¼ºæœ¦èƒ§æ„Ÿ
            scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.015);

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z);

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false,
                powerPreference: "high-performance",
                stencil: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;  // æ›´æŸ”å’Œçš„è‰²è°ƒæ˜ å°„
            renderer.toneMappingExposure = 1.8;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
            innerLight.position.set(0, 5, 0);
            mainGroup.add(innerLight);

            const spotGold = new THREE.SpotLight(0xffcc66, 1200);
            spotGold.position.set(30, 40, 40);
            spotGold.angle = 0.5;
            spotGold.penumbra = 0.5;
            scene.add(spotGold);

            const spotBlue = new THREE.SpotLight(0x6688ff, 600);
            spotBlue.position.set(-30, 20, -30);
            scene.add(spotBlue);

            const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
            fill.position.set(0, 0, 50);
            scene.add(fill);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            // æ›´æŸ”å’Œçš„å‘å…‰æ•ˆæœ
            bloomPass.threshold = 0.5;
            bloomPass.strength = 0.6;
            bloomPass.radius = 0.8;  // æ›´å¤§çš„æ¨¡ç³ŠåŠå¾„ï¼Œæ›´æœ¦èƒ§

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#880000';
            ctx.beginPath();
            for(let i=-128; i<256; i+=32) {
                ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = THREE.RepeatWrapping;
            caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
        }

        let photoIndex = 0;  // ç”¨äºåˆ†é…ç…§ç‰‡ä½ç½®

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh;
                this.type = type;
                this.isDust = isDust;
                this.posTree = new THREE.Vector3();
                this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x;
                const speedMult = (type === 'PHOTO') ? 0.3 : 2.0;
                this.spinSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * speedMult,
                    (Math.random() - 0.5) * speedMult,
                    (Math.random() - 0.5) * speedMult
                );

                // ç…§ç‰‡ç‹¬ç«‹æ—‹è½¬å‚æ•°
                if (type === 'PHOTO') {
                    this.photoRotSpeed = 0.2 + Math.random() * 0.4;  // ç‹¬ç«‹æ—‹è½¬é€Ÿåº¦
                    this.photoRotOffset = Math.random() * Math.PI * 2;  // åˆå§‹ç›¸ä½
                    this.photoTiltX = (Math.random() - 0.5) * 0.3;  // è½»å¾®å€¾æ–œ
                    this.photoTiltZ = (Math.random() - 0.5) * 0.3;
                    this.photoIdx = photoIndex++;
                }

                this.calculatePositions();
            }

            calculatePositions() {
                const h = CONFIG.particles.treeHeight;
                const halfH = h / 2;

                // ç…§ç‰‡ä½¿ç”¨å‡åŒ€åˆ†å¸ƒï¼Œé¿å…é‡å 
                if (this.type === 'PHOTO') {
                    const totalPhotos = 8;
                    // å‡åŒ€åˆ†å¸ƒåœ¨æ ‘çš„ä¸­ä¸‹éƒ¨ï¼ˆé¿å…é¡¶éƒ¨ï¼‰
                    const t = 0.15 + (this.photoIdx / totalPhotos) * 0.6;  // 0.15 åˆ° 0.75
                    const y = (t * h) - halfH;
                    // æ›´å¤§çš„åŠå¾„ï¼Œç¡®ä¿ç…§ç‰‡åœ¨å¤–å›´
                    const rMax = CONFIG.particles.treeRadius * (1.0 - t) + 2;
                    // å‡åŒ€åˆ†å¸ƒè§’åº¦
                    const angle = (this.photoIdx / totalPhotos) * Math.PI * 2 + Math.PI / 4;
                    const r = rMax * 0.9;
                    this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                } else {
                    let t = Math.random();
                    t = Math.pow(t, 0.8);
                    const y = (t * h) - halfH;
                    let rMax = CONFIG.particles.treeRadius * (1.0 - t);
                    if (rMax < 0.5) rMax = 0.5;
                    const angle = t * 50 * Math.PI + Math.random() * Math.PI;
                    const r = rMax * (0.8 + Math.random() * 0.4);
                    this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                }

                let rScatter = this.isDust ? (12 + Math.random()*20) : (8 + Math.random()*12);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );
            }

            update(dt, mode, focusTargetMesh) {
                let target = this.posTree;

                if (mode === 'SCATTER' || mode === 'GREETING') {
                    target = this.posScatter;
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const desiredWorldPos = new THREE.Vector3(0, 2, 35);
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else {
                        target = this.posScatter;
                    }
                }

                const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0;
                this.mesh.position.lerp(target, lerpSpeed * dt);

                // æ—‹è½¬é€»è¾‘
                if (this.type === 'PHOTO') {
                    // ç…§ç‰‡ç‹¬ç«‹æ—‹è½¬ï¼Œä¸è·Ÿéšåœ£è¯æ ‘
                    if (mode === 'SCATTER' || mode === 'GREETING') {
                        this.mesh.rotation.x += this.spinSpeed.x * dt;
                        this.mesh.rotation.y += this.spinSpeed.y * dt;
                        this.mesh.rotation.z += this.spinSpeed.z * dt;
                    } else if (mode === 'TREE') {
                        // ç‹¬ç«‹ç¼“æ…¢æ—‹è½¬ + è½»å¾®æ‘†åŠ¨
                        const time = clock.getElapsedTime();
                        this.mesh.rotation.y = time * this.photoRotSpeed + this.photoRotOffset;
                        this.mesh.rotation.x = this.photoTiltX + Math.sin(time * 0.5 + this.photoRotOffset) * 0.1;
                        this.mesh.rotation.z = this.photoTiltZ + Math.cos(time * 0.3 + this.photoRotOffset) * 0.08;
                    } else if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
                        this.mesh.lookAt(camera.position);
                    }
                } else {
                    // å…¶ä»–ç²’å­ä¿æŒåŸæœ‰é€»è¾‘
                    if (mode === 'SCATTER' || mode === 'GREETING') {
                        this.mesh.rotation.x += this.spinSpeed.x * dt;
                        this.mesh.rotation.y += this.spinSpeed.y * dt;
                        this.mesh.rotation.z += this.spinSpeed.z * dt;
                    } else if (mode === 'TREE') {
                        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
                        this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
                        this.mesh.rotation.y += 0.5 * dt;
                    }

                    if (mode === 'FOCUS' && this.mesh === focusTargetMesh) {
                        this.mesh.lookAt(camera.position);
                    }
                }

                let s = this.baseScale;
                if (this.isDust) {
                    s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
                    if (mode === 'TREE') s = 0;
                } else if (this.type === 'PHOTO') {
                    // ç›¸æ¡†åœ¨å„æ¨¡å¼ä¸‹çš„ç¼©æ”¾
                    if (mode === 'TREE') {
                        s = this.baseScale * 1.2;  // èšåˆæ€ï¼šæ›´å¤§æ›´æ˜¾çœ¼
                    } else if (mode === 'SCATTER') {
                        s = this.baseScale * 2.0;  // åˆ†æ•£æ€ï¼šçªå‡ºæ˜¾ç¤º
                    } else if (mode === 'GREETING') {
                        s = this.baseScale * 1.3;  // ç¥ç¦è¯­æ¨¡å¼ï¼šç¨å°
                    } else if (mode === 'FOCUS') {
                        if (this.mesh === focusTargetMesh) {
                            s = 3.5;  // èšç„¦çš„ç…§ç‰‡
                        } else {
                            s = this.baseScale * 0.6;  // å…¶ä»–ç…§ç‰‡ç¼©å°
                        }
                    }
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) s = 4.5;
                    else s = this.baseScale * 0.8;
                }

                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
            }
        }

        function createParticles() {
            // æ›´é«˜ç»†åˆ†åº¦ï¼Œè¾¹ç¼˜æ›´å¹³æ»‘
            const sphereGeo = new THREE.SphereGeometry(0.5, 64, 64);
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55, 4, 4, 4);
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)
            ]);
            const candyGeo = new THREE.TubeGeometry(curve, 32, 0.08, 16, false);

            const goldMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.champagneGold,
                metalness: 1.0, roughness: 0.05,
                envMapIntensity: 2.5,
                emissive: 0x443300,
                emissiveIntensity: 0.3,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            });

            const greenMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.deepGreen,
                metalness: 0.3, roughness: 0.6,
                emissive: 0x002200,
                emissiveIntensity: 0.2,
                sheen: 0.5,
                sheenRoughness: 0.5,
                sheenColor: new THREE.Color(0x004400)
            });

            const redMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.colors.accentRed,
                metalness: 0.4, roughness: 0.15,
                clearcoat: 1.0,
                clearcoatRoughness: 0.05,
                emissive: 0x330000,
                emissiveIntensity: 0.2
            });

            const candyMat = new THREE.MeshPhysicalMaterial({
                map: caneTexture,
                roughness: 0.3,
                clearcoat: 0.8,
                clearcoatRoughness: 0.1
            });

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;

                if (rand < 0.40) {
                    mesh = new THREE.Mesh(boxGeo, greenMat);
                    type = 'BOX';
                } else if (rand < 0.70) {
                    mesh = new THREE.Mesh(boxGeo, goldMat);
                    type = 'GOLD_BOX';
                } else if (rand < 0.92) {
                    mesh = new THREE.Mesh(sphereGeo, goldMat);
                    type = 'GOLD_SPHERE';
                } else if (rand < 0.97) {
                    mesh = new THREE.Mesh(sphereGeo, redMat);
                    type = 'RED';
                } else {
                    mesh = new THREE.Mesh(candyGeo, candyMat);
                    type = 'CANE';
                }

                const s = 0.4 + Math.random() * 0.5;
                mesh.scale.set(s,s,s);
                mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);

                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, false));
            }

            const starGeo = new THREE.OctahedronGeometry(1.2, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0,
                metalness: 1.0, roughness: 0
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
            mainGroup.add(star);

            mainGroup.add(photoMeshGroup);
        }

        // åˆ›å»ºä¸åŒæ¨¡ç³Šç¨‹åº¦çš„é›ªèŠ±çº¹ç†
        function createSnowflakeTexture(blurLevel) {
            const canvas = document.createElement('canvas');
            const size = 64;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            const center = size / 2;
            // blurLevel: 0 = æ¸…æ™°, 1 = æœ€æ¨¡ç³Š
            const innerRadius = center * (0.1 + blurLevel * 0.2);
            const gradient = ctx.createRadialGradient(center, center, innerRadius, center, center, center);

            if (blurLevel < 0.3) {
                // è¿‘æ™¯ï¼šæ¸…æ™°çš„é›ªèŠ±
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.3, 'rgba(255, 252, 245, 0.9)');
                gradient.addColorStop(0.6, 'rgba(255, 248, 235, 0.5)');
                gradient.addColorStop(0.85, 'rgba(255, 245, 225, 0.15)');
                gradient.addColorStop(1, 'rgba(255, 240, 210, 0)');
            } else if (blurLevel < 0.6) {
                // ä¸­æ™¯ï¼šç¨æ¨¡ç³Š
                gradient.addColorStop(0, 'rgba(255, 252, 245, 0.8)');
                gradient.addColorStop(0.4, 'rgba(255, 248, 235, 0.5)');
                gradient.addColorStop(0.7, 'rgba(255, 245, 225, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 240, 210, 0)');
            } else {
                // è¿œæ™¯ï¼šå¾ˆæ¨¡ç³Š
                gradient.addColorStop(0, 'rgba(255, 250, 240, 0.5)');
                gradient.addColorStop(0.5, 'rgba(255, 245, 230, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 240, 220, 0)');
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function createDust() {
            // åˆ›å»ºä¸‰å±‚é›ªèŠ±ï¼šè¿‘æ™¯ã€ä¸­æ™¯ã€è¿œæ™¯
            const layers = [
                { count: 150, zRange: [20, 40], size: [0.3, 0.6], speed: [0.8, 1.5], blur: 0.1, opacity: 0.9 },   // è¿‘æ™¯
                { count: 300, zRange: [-10, 25], size: [0.15, 0.35], speed: [0.5, 1.0], blur: 0.4, opacity: 0.6 }, // ä¸­æ™¯
                { count: 400, zRange: [-40, -5], size: [0.08, 0.2], speed: [0.2, 0.5], blur: 0.8, opacity: 0.3 }   // è¿œæ™¯
            ];

            layers.forEach((layer, layerIndex) => {
                const texture = createSnowflakeTexture(layer.blur);
                const snowData = [];

                for (let i = 0; i < layer.count; i++) {
                    const x = (Math.random() - 0.5) * 80;
                    const y = Math.random() * 60 - 10;
                    const z = layer.zRange[0] + Math.random() * (layer.zRange[1] - layer.zRange[0]);
                    const size = layer.size[0] + Math.random() * (layer.size[1] - layer.size[0]);
                    const fallSpeed = layer.speed[0] + Math.random() * (layer.speed[1] - layer.speed[0]);
                    const swaySpeed = 0.5 + Math.random() * 1.5;
                    const swayAmount = 0.3 + Math.random() * 0.7;
                    const initialPhase = Math.random() * Math.PI * 2;

                    snowData.push({
                        x, y, z, size, fallSpeed, swaySpeed, swayAmount, initialPhase,
                        originalX: x
                    });
                }

                // åˆ›å»ºç²¾çµæè´¨
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: layer.opacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const sprites = [];
                snowData.forEach(data => {
                    const sprite = new THREE.Sprite(spriteMaterial.clone());
                    sprite.position.set(data.x, data.y, data.z);
                    sprite.scale.set(data.size, data.size, 1);
                    sprite.userData = data;
                    scene.add(sprite);
                    sprites.push(sprite);
                });

                snowLayers.push({
                    sprites,
                    layerIndex
                });
            });

            // åŸæ¥çš„ç°å°˜ç²’å­ï¼ˆæ ‘ä¸Šé£˜åŠ¨çš„å°ç²’å­ï¼‰
            const geo = new THREE.SphereGeometry(0.05, 6, 6);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xffeedd,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });

            for(let i = 0; i < CONFIG.particles.dustCount; i++) {
                const mesh = new THREE.Mesh(geo, mat.clone());
                mesh.material.opacity = 0.2 + Math.random() * 0.3;
                mesh.scale.setScalar(0.3 + Math.random() * 0.7);
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, 'DUST', true));
            }
        }

        // æ›´æ–°é›ªèŠ±åŠ¨ç”»
        function updateSnow(time) {
            snowLayers.forEach(layer => {
                layer.sprites.forEach(sprite => {
                    const data = sprite.userData;

                    // ä¸‹è½
                    data.y -= data.fallSpeed * 0.05;

                    // å·¦å³æ‘‡æ‘†
                    const sway = Math.sin(time * data.swaySpeed + data.initialPhase) * data.swayAmount;
                    sprite.position.x = data.originalX + sway;
                    sprite.position.y = data.y;

                    // è½»å¾®æ—‹è½¬æ•ˆæœï¼ˆé€šè¿‡ç¼©æ”¾æ¨¡æ‹Ÿï¼‰
                    const scaleVar = 1 + Math.sin(time * 2 + data.initialPhase) * 0.1;
                    sprite.scale.set(data.size * scaleVar, data.size * scaleVar, 1);

                    // å¾ªç¯ï¼šè½åˆ°åº•éƒ¨åå›åˆ°é¡¶éƒ¨
                    if (data.y < -30) {
                        data.y = 50 + Math.random() * 10;
                        data.originalX = (Math.random() - 0.5) * 80;
                    }
                });
            });
        }

        async function createDefaultPhotos() {
            const photos = [
                'photos/photo1.jpg',
                'photos/photo2.jpg',
                'photos/photo3.jpg',
                'photos/photo4.jpg',
                'photos/photo5.jpg',
                'photos/photo6.jpg',
                'photos/photo7.jpg',
                'photos/photo8.jpg'
            ];

            const loader = new THREE.TextureLoader();
            const loadPromises = photos.map(photoPath => {
                return new Promise((resolve) => {
                    loader.load(photoPath, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        addPhotoToScene(texture);
                        resolve();
                    }, undefined, () => resolve());
                });
            });
            await Promise.all(loadPromises);
        }

        function addPhotoToScene(texture) {
            const imgWidth = texture.image.width;
            const imgHeight = texture.image.height;
            const aspect = imgWidth / imgHeight;

            // å¢å¤§åŸºç¡€å°ºå¯¸
            const baseSize = 2.0;
            let photoW, photoH;
            if (aspect > 1) {
                photoW = baseSize;
                photoH = baseSize / aspect;
            } else {
                photoH = baseSize;
                photoW = baseSize * aspect;
            }

            // ç²¾è‡´ç›¸æ¡† - å¤šå±‚ç»“æ„ï¼ˆå¢å¤§ z é—´è·é˜²æ­¢æ’•è£‚ï¼‰
            const group = new THREE.Group();

            // å¤–æ¡† - é‡‘è‰²ä¸»æ¡†
            const outerFrameW = photoW + 0.25;
            const outerFrameH = photoH + 0.25;
            const outerFrameGeo = new THREE.BoxGeometry(outerFrameW, outerFrameH, 0.1);
            const outerFrameMat = new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                metalness: 1.0,
                roughness: 0.15,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                envMapIntensity: 2.0,
                depthWrite: true,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            const outerFrame = new THREE.Mesh(outerFrameGeo, outerFrameMat);
            outerFrame.renderOrder = 0;
            group.add(outerFrame);

            // å†…æ¡† - æ·±è‰²è¡¬åº•
            const innerFrameW = photoW + 0.06;
            const innerFrameH = photoH + 0.06;
            const innerFrameGeo = new THREE.BoxGeometry(innerFrameW, innerFrameH, 0.08);
            const innerFrameMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.3,
                roughness: 0.8,
                depthWrite: true
            });
            const innerFrame = new THREE.Mesh(innerFrameGeo, innerFrameMat);
            innerFrame.position.z = 0.06;
            innerFrame.renderOrder = 1;
            group.add(innerFrame);

            // ç…§ç‰‡ - å¢åŠ  z è·ç¦»
            const photoGeo = new THREE.PlaneGeometry(photoW, photoH);
            const photoMat = new THREE.MeshBasicMaterial({
                map: texture,
                depthWrite: true,
                depthTest: true,
                transparent: false
            });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.12;
            photo.renderOrder = 2;
            group.add(photo);

            // è£…é¥°è§’ - å››ä¸ªè§’çš„é‡‘è‰²è£…é¥°
            const cornerSize = 0.1;
            const cornerGeo = new THREE.BoxGeometry(cornerSize, cornerSize, 0.12);
            const cornerMat = new THREE.MeshPhysicalMaterial({
                color: 0xffcc00,
                metalness: 1.0,
                roughness: 0.1,
                emissive: 0x332200,
                emissiveIntensity: 0.3,
                depthWrite: true
            });

            const corners = [
                [-outerFrameW/2 + cornerSize/2, outerFrameH/2 - cornerSize/2, 0.06],
                [outerFrameW/2 - cornerSize/2, outerFrameH/2 - cornerSize/2, 0.06],
                [-outerFrameW/2 + cornerSize/2, -outerFrameH/2 + cornerSize/2, 0.06],
                [outerFrameW/2 - cornerSize/2, -outerFrameH/2 + cornerSize/2, 0.06]
            ];

            corners.forEach((pos, i) => {
                const corner = new THREE.Mesh(cornerGeo, cornerMat);
                corner.position.set(...pos);
                corner.renderOrder = 3;
                group.add(corner);
            });

            const s = 1.0;
            group.scale.set(s, s, s);

            photoMeshGroup.add(group);
            particleSystem.push(new Particle(group, 'PHOTO', false));
        }

        function setupKeyboardControls() {
            // æŒ‰é”®æŒ‰ä¸‹
            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();

                // Q/E æ—‹è½¬æ§åˆ¶
                if (key === 'q') STATE.keys.q = true;
                if (key === 'e') STATE.keys.e = true;

                switch(key) {
                    case 's':
                        STATE.mode = 'SCATTER';
                        STATE.focusTarget = null;
                        STATE.currentPhotoIndex = -1;
                        STATE.showingGreeting = false;
                        hideGreeting();
                        break;
                    case 't':
                        STATE.mode = 'TREE';
                        STATE.focusTarget = null;
                        STATE.currentPhotoIndex = -1;
                        STATE.showingGreeting = false;
                        hideGreeting();
                        break;
                    case 'f':
                        handleFocusKey();
                        break;
                }
            });

            // æŒ‰é”®æ¾å¼€
            window.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'q') STATE.keys.q = false;
                if (key === 'e') STATE.keys.e = false;
            });
        }

        function handleFocusKey() {
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            if (photos.length === 0) return;

            if (STATE.showingGreeting) {
                hideGreeting();
                STATE.showingGreeting = false;
                STATE.currentPhotoIndex = -1;
            }

            STATE.currentPhotoIndex++;

            if (STATE.currentPhotoIndex >= photos.length) {
                STATE.mode = 'GREETING';
                STATE.focusTarget = null;
                STATE.showingGreeting = true;
                showGreeting();
                return;
            }

            STATE.mode = 'FOCUS';
            STATE.focusTarget = photos[STATE.currentPhotoIndex].mesh;
        }

        function createGreetingTexture(glowIntensity = 30) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#fff8dc');
            gradient.addColorStop(0.3, '#ffd700');
            gradient.addColorStop(0.5, '#ffec8b');
            gradient.addColorStop(0.7, '#ffd700');
            gradient.addColorStop(1, '#daa520');

            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = glowIntensity;
            ctx.fillStyle = gradient;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.font = 'italic bold 72px "Cinzel", "Times New Roman", serif';
            ctx.fillText('Merry Christmas', canvas.width / 2, canvas.height / 2 - 60);

            ctx.font = 'italic 48px "Times New Roman", serif';
            ctx.fillText('&', canvas.width / 2, canvas.height / 2 + 10);

            ctx.font = 'italic bold 72px "Cinzel", "Times New Roman", serif';
            ctx.fillText('Happy Birthday!', canvas.width / 2, canvas.height / 2 + 80);

            ctx.font = '36px serif';
            ctx.fillText('âœ¦', canvas.width / 2 - 280, canvas.height / 2 - 60);
            ctx.fillText('âœ¦', canvas.width / 2 + 280, canvas.height / 2 - 60);
            ctx.fillText('âœ¦', canvas.width / 2 - 260, canvas.height / 2 + 80);
            ctx.fillText('âœ¦', canvas.width / 2 + 260, canvas.height / 2 + 80);

            return new THREE.CanvasTexture(canvas);
        }

        let greetingGlowMesh = null;
        let greetingCalmMesh = null;
        let greetingFadeStart = 0;

        function showGreeting() {
            if (greetingGlowMesh && greetingCalmMesh) {
                // é‡æ–°æ˜¾ç¤ºå¹¶é‡ç½®åŠ¨ç”»
                greetingGlowMesh.visible = true;
                greetingCalmMesh.visible = true;
                greetingGlowMesh.material.opacity = 1;
                greetingCalmMesh.material.opacity = 0;
                greetingFadeStart = clock.getElapsedTime();
                return;
            }

            const geometry = new THREE.PlaneGeometry(12, 6);

            // é—ªäº®ç‰ˆæœ¬
            const glowTexture = createGreetingTexture(30);
            glowTexture.colorSpace = THREE.SRGBColorSpace;
            const glowMaterial = new THREE.MeshBasicMaterial({
                map: glowTexture,
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 1
            });
            greetingGlowMesh = new THREE.Mesh(geometry, glowMaterial);
            greetingGlowMesh.position.set(0, 2, 35);
            scene.add(greetingGlowMesh);

            // æ¸…æ™°ç‰ˆæœ¬ï¼ˆä½å‘å…‰ï¼‰
            const calmTexture = createGreetingTexture(5);
            calmTexture.colorSpace = THREE.SRGBColorSpace;
            const calmMaterial = new THREE.MeshBasicMaterial({
                map: calmTexture,
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0
            });
            greetingCalmMesh = new THREE.Mesh(geometry.clone(), calmMaterial);
            greetingCalmMesh.position.set(0, 2, 34.9);
            scene.add(greetingCalmMesh);

            greetingFadeStart = clock.getElapsedTime();
        }

        function updateGreetingFade() {
            if (!greetingGlowMesh || !greetingCalmMesh) return;
            if (!greetingGlowMesh.visible) return;

            const elapsed = clock.getElapsedTime() - greetingFadeStart;
            const fadeDelay = 1.5;   // 1.5ç§’åå¼€å§‹æ¸å˜
            const fadeDuration = 1.5; // æ¸å˜æŒç»­1.5ç§’

            if (elapsed > fadeDelay) {
                const fadeProgress = Math.min((elapsed - fadeDelay) / fadeDuration, 1);
                greetingGlowMesh.material.opacity = 1 - fadeProgress;
                greetingCalmMesh.material.opacity = fadeProgress;
            }
        }

        function hideGreeting() {
            if (greetingGlowMesh) greetingGlowMesh.visible = false;
            if (greetingCalmMesh) greetingCalmMesh.visible = false;
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'h') {
                    const controls = document.querySelector('.hint-wrapper');
                    if (controls) controls.classList.toggle('ui-hidden');
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // æ›´æ–°é›ªèŠ±åŠ¨ç”»
            updateSnow(time);

            // æ‰‹åŠ¨æ—‹è½¬æ§åˆ¶ (Q/Eé”®)
            const mr = STATE.manualRotation;

            // è®¡ç®—ç›®æ ‡é€Ÿåº¦
            if (STATE.keys.q) {
                mr.targetVelocity = -mr.maxSpeed;  // å·¦è½¬
            } else if (STATE.keys.e) {
                mr.targetVelocity = mr.maxSpeed;   // å³è½¬
            } else {
                mr.targetVelocity = 0;
            }

            // å¹³æ»‘åŠ é€Ÿ/å‡é€Ÿ
            if (STATE.keys.q || STATE.keys.e) {
                // æŒ‰é”®æ—¶åŠ é€Ÿ
                mr.velocity += (mr.targetVelocity - mr.velocity) * mr.acceleration * dt * 5;
            } else {
                // æ¾å¼€æ—¶æƒ¯æ€§å‡é€Ÿ
                mr.velocity *= mr.friction;
                // é€Ÿåº¦å¾ˆå°æ—¶ç›´æ¥å½’é›¶
                if (Math.abs(mr.velocity) < 0.001) mr.velocity = 0;
            }

            // åº”ç”¨æ‰‹åŠ¨æ—‹è½¬
            const manualRotationDelta = mr.velocity * dt;

            // è‡ªåŠ¨æ—‹è½¬é€»è¾‘ï¼ˆä¸æ‰‹åŠ¨æ—‹è½¬å åŠ ï¼‰
            let autoRotationDelta = 0;
            if(STATE.mode === 'TREE') {
                autoRotationDelta = 0.3 * dt;
                STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
            } else {
                autoRotationDelta = 0.1 * dt;
            }

            // åˆå¹¶æ—‹è½¬ï¼šè‡ªåŠ¨ + æ‰‹åŠ¨
            STATE.rotation.y += autoRotationDelta + manualRotationDelta;

            mainGroup.rotation.y = STATE.rotation.y;
            mainGroup.rotation.x = STATE.rotation.x;

            // æ›´æ–°ç¥ç¦è¯­æ¸å˜åŠ¨ç”»
            updateGreetingFade();

            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            composer.render();
        }

        // ç­‰å¾…å¯†ç éªŒè¯åæ‰åˆå§‹åŒ–
        window.addEventListener('startApp', init);
    </script>
</body>
</html>
